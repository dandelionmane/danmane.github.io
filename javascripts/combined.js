// Generated by CoffeeScript 1.6.2
(function() {
  var ALWAYS_REPRODUCE, Blob, C, Environment, Gene, GeneCode, InfoArea, QTNode, QuadTree, Simulation, Vector2D, maxByIndex, minByIndex, randomSign, simulator_draw;

  C = (function() {
    var _ref, _ref1;

    function C() {}

    C.DISPLAY_X = (_ref = window.innerWidth - 20) != null ? _ref : 1000;

    C.DISPLAY_Y = (_ref1 = window.innerHeight - 20) != null ? _ref1 : 500;

    C.X_BOUND = C.DISPLAY_X + 200;

    C.Y_BOUND = C.DISPLAY_Y + 200;

    C.DISPLAY_BOUND = 0;

    C.INFO_WINDOW = false;

    C.SMALL_SIZE = 10;

    C.MEDIUM_SIZE = 30;

    C.LARGE_SIZE = 60;

    C.HUGE_SIZE = 200;

    C.TWO_TRADEOFF = false;

    C.NEIGHBOR_DISTANCE = 20;

    C.CHILD_DISTANCE = 5;

    C.ATTACK_MARGIN = 100;

    C.STARTING_ENERGY = 200;

    C.STARTING_BLOBS = 200;

    C.MOVEMENT_PER_ENERGY = 100;

    C.REPR_ENERGY_COST = 700;

    C.MOVEMENT_SPEED_FACTOR = .05;

    C.PHO_EPS = -.05;

    C.PHO_SQ_EPS = .06;

    C.ATK_EPS = -1;

    C.ATK_SQ_EPS = -.003;

    C.SPD_EPS = 0;

    C.AGE_ENERGY_DECAY = .001;

    C.RADIUS_FACTOR = .1;

    C.RADIUS_CONSTANT = 5;

    C.ENERGY_DECAY = .005;

    C.REPR_TIME_REQUIREMENT = 7;

    C.MUTATION_PROBABILITY = .1;

    C.MUTATION_CONSTANT = .5;

    C.QTREE_BUCKET_SIZE = 50;

    C.FRAME_RATE = 30;

    C.MOVE_UPDATE_AMT = 5;

    return C;

  })();

  randomSign = function() {
    if (Math.random() > .5) {
      return 1;
    } else {
      return -1;
    }
  };

  maxByIndex = function(arrayOfArrays, index) {
    "Get the maximum Array in an Array of Arrays according to \nordering by one of the indexes\ne.g. maxByElem [[\"hello\", 1], [\"goodbye\", 2]], 1 -> [\"goodbye\", 2]";
    var arr, maxArray, maxIndex, _i, _len;

    if (!arrayOfArrays.length) {
      return null;
    }
    maxIndex = arrayOfArrays[0][index];
    maxArray = arrayOfArrays[0];
    for (_i = 0, _len = arrayOfArrays.length; _i < _len; _i++) {
      arr = arrayOfArrays[_i];
      if (arr[index] > maxIndex) {
        maxIndex = arr[index];
        maxArray = arr;
      }
    }
    if (maxIndex == null) {
      throw new Error("maxByIndex: Index out of bounds for entire array");
    }
    return maxArray;
  };

  minByIndex = function(arrayOfArrays, index) {
    "Get the minimum Array in an Array of Arrays according to \nordering by one of the indexes\ne.g. minByElem [[\"hello\", 1], [\"goodbye\", 2]], 1 -> [\"goodbye\", 2]";
    var arr, minArray, minIndex, _i, _len;

    if (!arrayOfArrays.length) {
      return null;
    }
    minIndex = arrayOfArrays[0][index];
    minArray = arrayOfArrays[0];
    for (_i = 0, _len = arrayOfArrays.length; _i < _len; _i++) {
      arr = arrayOfArrays[_i];
      if (arr[index] < minIndex) {
        minIndex = arr[index];
        minArray = arr;
      }
    }
    if (minIndex == null) {
      throw new Error("minByIndex: Index out of bounds for entire array");
    }
    return minArray;
  };

  Math.PI2 = 2 * Math.PI;

  Vector2D = (function() {
    var name, _fn, _i, _len, _ref;

    _ref = ['add', 'subtract', 'multiply', 'divide'];
    _fn = function(name) {
      return Vector2D[name] = function(a, b) {
        return a.copy()[name](b);
      };
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      _fn(name);
    }

    Vector2D.randomUnitVector = function() {
      var v;

      v = new Vector2D(Math.random() - .5, Math.random() - .5);
      return v.normalize();
    };

    Vector2D.randomVector = function(xMax, yMax) {
      return new Vector2D(Math.random() * xMax, Math.random() * yMax);
    };

    Vector2D.randomHeading = function() {
      return Math.random() * Math.PI2;
    };

    Vector2D.negateHeading = function(h) {
      return (h + Math.PI) % Math.PI2;
    };

    Vector2D.headingVector = function(h) {
      return new Vector2D(Math.cos(h), Math.sin(h));
    };

    function Vector2D(x, y) {
      var _ref1;

      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      _ref1 = [x, y], this.x = _ref1[0], this.y = _ref1[1];
    }

    Vector2D.prototype.copy = function() {
      return new Vector2D(this.x, this.y);
    };

    Vector2D.prototype.magnitude = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    Vector2D.prototype.normalize = function() {
      var m;

      m = this.magnitude();
      if (m > 0) {
        this.divide(m);
      }
      return this;
    };

    Vector2D.prototype.limit = function(max) {
      if (this.magnitude() > max) {
        this.normalize();
        return this.multiply(max);
      } else {
        return this;
      }
    };

    Vector2D.prototype.heading = function() {
      return (Math.atan2(this.y, this.x) + Math.PI2) % Math.PI2;
    };

    Vector2D.prototype.eucl_distance = function(other) {
      var dx, dy;

      dx = this.x - other.x;
      dy = this.y - other.y;
      return Math.sqrt(dx * dx + dy * dy);
    };

    Vector2D.prototype.distSq = function(other) {
      var dx, dy;

      dx = this.x - other.x;
      dy = this.y - other.y;
      return dx * dx + dy * dy;
    };

    Vector2D.prototype.distance = function(other, dimensions) {
      var dx, dy;

      if (dimensions == null) {
        dimensions = false;
      }
      dx = Math.abs(this.x - other.x);
      dy = Math.abs(this.y - other.y);
      if (dimensions) {
        dx = dx < dimensions.width / 2 ? dx : dimensions.width - dx;
        dy = dy < dimensions.height / 2 ? dy : dimensions.height - dy;
      }
      return Math.sqrt(dx * dx + dy * dy);
    };

    Vector2D.prototype.subtract = function(other) {
      this.x -= other.x;
      this.y -= other.y;
      return this;
    };

    Vector2D.prototype.add = function(other) {
      this.x += other.x;
      this.y += other.y;
      return this;
    };

    Vector2D.prototype.divide = function(n) {
      var _ref1;

      _ref1 = [this.x / n, this.y / n], this.x = _ref1[0], this.y = _ref1[1];
      return this;
    };

    Vector2D.prototype.multiply = function(n) {
      var _ref1;

      _ref1 = [this.x * n, this.y * n], this.x = _ref1[0], this.y = _ref1[1];
      return this;
    };

    Vector2D.prototype.dot = function(other) {
      return this.x * other.x + this.y * other.y;
    };

    Vector2D.prototype.projectOnto = function(other) {
      return other.copy().multiply(this.dot(other));
    };

    Vector2D.prototype.wrapToBound = function(xBound, yBound) {
      this.x = (this.x + xBound) % xBound;
      return this.y = (this.y + yBound) % yBound;
    };

    Vector2D.prototype.wrapRelativeTo = function(location, dimensions) {
      var a, d, key, map_d, v, _ref1;

      v = this.copy();
      _ref1 = {
        x: "width",
        y: "height"
      };
      for (a in _ref1) {
        key = _ref1[a];
        d = this[a] - location[a];
        map_d = dimensions[key];
        if (Math.abs(d) > map_d / 2) {
          if (d > 0) {
            v[a] = (map_d - this[a]) * -1;
          } else {
            v[a] = this[a] + map_d;
          }
        }
      }
      return v;
    };

    Vector2D.prototype.invalid = function() {
      return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y);
    };

    return Vector2D;

  })();

  QuadTree = (function() {
    "Maintain a QuadTree of objects on a 2D space.\nEach object is represented by a unique id and has an associated 2D point.\nMaps from IDs to Vector2D points, and back. \nPoints do not uniquely identify an Id,Point combo because\nmultiple IDs may share the same location. IDs\nmust be unique.\nNOTE: QuadTree may break if >bucketSize points have exact same coordinate\nSuggest fixing by adding tiny random disturbance to avoid this situation";    function QuadTree(xBound, yBound, bucketSize) {
      this.xBound = xBound;
      this.yBound = yBound;
      this.bucketSize = bucketSize;
      this.id2point = {};
      this.numPoints = 0;
      this.tree = new QTNode(this.xBound / 2, this.yBound / 2, this.xBound / 2, this.yBound / 2, this.bucketSize);
    }

    QuadTree.prototype.addObject = function(id, point) {
      var _ref, _ref1;

      if (!((0 < (_ref = point.x) && _ref < this.xBound) && (0 < (_ref1 = point.y) && _ref1 < this.yBound))) {
        throw new Error("Index out of bounds: " + point.x + ", " + point.y);
      }
      if (id in this.id2point && !this.rebuilding) {
        throw Error("Object ID collision on id: " + id);
      }
      this.id2point[id] = point;
      this.tree.addPoint(id, point);
      return ++this.numPoints;
    };

    QuadTree.prototype.removeObject = function(id) {
      var p;

      if (!(id in this.id2point)) {
        throw Error("Tried to remove ID that isn't in map");
      }
      p = this.id2point[id];
      this.tree.removePoint(id, p);
      delete this.id2point[id];
      return --this.numPoints;
    };

    QuadTree.prototype.moveObject = function(id, newPoint) {
      this.removeObject(id);
      return this.addObject(id, newPoint);
    };

    QuadTree.prototype.calculateDistance = function(id1, id2) {
      var p1, p2;

      p1 = this.id2point[id1];
      p2 = this.id2point[id2];
      return p1.eucl_distance(p2);
    };

    QuadTree.prototype.circleQuery = function(centerPoint, radius) {
      "Returns a list of all object IDs that fall within the circle";      return this.tree.circleQuery(centerPoint, radius, radius * radius);
    };

    QuadTree.prototype.approximateCircleQuery = function(centerPoint, radius) {
      "Returns a list of all object IDs that fall in nodes that intersect the circle";      return this.tree.approximateCircleQuery(centerPoint, radius, radius * radius);
    };

    QuadTree.prototype.rebuild = function() {
      var id, pt, _ref;

      this.rebuilding = true;
      this.tree = new QTNode(this.xBound / 2, this.yBound / 2, this.xBound / 2, this.yBound / 2, this.bucketSize);
      _ref = this.id2point;
      for (id in _ref) {
        pt = _ref[id];
        this.addObject(id, pt);
      }
      return this.rebuilding = false;
    };

    return QuadTree;

  })();

  QTNode = (function() {
    function QTNode(x, y, xEdge, yEdge, bucketSize, depth) {
      var MM, MP, PM, PP;

      this.x = x;
      this.y = y;
      this.xEdge = xEdge;
      this.yEdge = yEdge;
      this.bucketSize = bucketSize;
      this.depth = depth != null ? depth : 0;
      this.leaf = true;
      this.points = {};
      this.nPoints = 0;
      MM = new Vector2D(this.x - this.xEdge, this.y - this.yEdge);
      MP = new Vector2D(this.x - this.xEdge, this.y + this.yEdge);
      PM = new Vector2D(this.x + this.xEdge, this.y - this.yEdge);
      PP = new Vector2D(this.x + this.xEdge, this.y + this.yEdge);
      this.corners = [MM, MP, PM, PP];
    }

    QTNode.prototype.addPoint = function(id, p) {
      var id_, idx, p_, pts, _results;

      this.nPoints++;
      this.points[id] = p;
      if (this.leaf) {
        if (this.nPoints > this.bucketSize) {
          this.leaf = false;
          this.createChildren();
          this.nPoints = 0;
          pts = this.points;
          this.points = {};
          _results = [];
          for (id_ in pts) {
            p_ = pts[id_];
            _results.push(this.addPoint(id_, p_));
          }
          return _results;
        }
      } else {
        idx = 2 * (p.x > this.x) + (p.y > this.y);
        return this.children[idx].addPoint(id, p);
      }
    };

    QTNode.prototype.createChildren = function() {
      var MM, MP, PM, PP, newXEdge, newYEdge;

      if (this.children != null) {
        throw new Error("Non-leaf node tried to make children");
      }
      newXEdge = this.xEdge / 2;
      newYEdge = this.yEdge / 2;
      if (this.depth > 4000) {
        console.log(this.points);
      }
      MM = new QTNode(this.x - newXEdge, this.y - newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
      MP = new QTNode(this.x - newXEdge, this.y + newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
      PM = new QTNode(this.x + newXEdge, this.y - newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
      PP = new QTNode(this.x + newXEdge, this.y + newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
      return this.children = [MM, MP, PM, PP];
    };

    QTNode.prototype.removePoint = function(id, p) {
      var idx;

      if (!(id in this.points)) {
        throw new Error("Tried to remove id not in QTNode");
      }
      delete this.points[id];
      --this.nPoints;
      if (!this.leaf) {
        idx = 2 * (p.x > this.x) + (p.y > this.y);
        return this.children[idx].removePoint(id, p);
      }
    };

    QTNode.prototype.nearbyPoints = function(centerPoint, maxDist) {
      var distSq, grandparent, id, idx, parent, pt, pts, _ref, _ref1, _results;

      if (this.leaf) {
        distSq = maxDist * maxDist;
        parent = (_ref = this.parent) != null ? _ref : this;
        grandparent = (_ref1 = parent.parent) != null ? _ref1 : parent;
        pts = grandparent.points;
        _results = [];
        for (id in pts) {
          pt = pts[id];
          if (centerPoint.distSq(pt) <= distSq) {
            _results.push(id);
          }
        }
        return _results;
      } else {
        idx = 2 * (centerPoint.x > this.x) + (centerPoint.y > this.y);
        return this.children[idx].nearbyPoints(centerPoint, maxDist);
      }
    };

    QTNode.prototype.circleQuery = function(centerPoint, radius, radiusSq) {
      var c, id, intersect, minDist2Corner, pt, xDist, yDist, _ref, _ref1, _results;

      intersect = false;
      xDist = Math.abs(centerPoint.x - this.x);
      yDist = Math.abs(centerPoint.y - this.y);
      intersect || (intersect = xDist <= this.xEdge && yDist <= this.yEdge + radius);
      intersect || (intersect = yDist <= this.yEdge && xDist <= this.xEdge + radius);
      minDist2Corner = Math.min.apply(Math, (function() {
        var _i, _len, _ref, _results;

        _ref = this.corners;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          _results.push(centerPoint.distSq(c));
        }
        return _results;
      }).call(this));
      intersect || (intersect = minDist2Corner <= radiusSq);
      if (intersect) {
        if (this.leaf) {
          _ref = this.points;
          _results = [];
          for (id in _ref) {
            pt = _ref[id];
            if (centerPoint.distSq(pt) <= radiusSq) {
              _results.push(id);
            }
          }
          return _results;
        } else {
          return (_ref1 = []).concat.apply(_ref1, (function() {
            var _i, _len, _ref1, _results1;

            _ref1 = this.children;
            _results1 = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              c = _ref1[_i];
              _results1.push(c.circleQuery(centerPoint, radius, radiusSq));
            }
            return _results1;
          }).call(this));
        }
      } else {
        return [];
      }
    };

    QTNode.prototype.approximateCircleQuery = function(centerPoint, radius, radiusSq) {
      var c, id, intersect, minDist2Corner, pt, xDist, yDist, _ref, _ref1, _results;

      intersect = false;
      xDist = Math.abs(centerPoint.x - this.x);
      yDist = Math.abs(centerPoint.y - this.y);
      intersect || (intersect = xDist <= this.xEdge && yDist <= this.yEdge + radius);
      intersect || (intersect = yDist <= this.yEdge && xDist <= this.xEdge + radius);
      minDist2Corner = Math.min.apply(Math, (function() {
        var _i, _len, _ref, _results;

        _ref = this.corners;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          _results.push(centerPoint.distSq(c));
        }
        return _results;
      }).call(this));
      intersect || (intersect = minDist2Corner <= radiusSq);
      if (intersect) {
        if (this.leaf) {
          _ref = this.points;
          _results = [];
          for (id in _ref) {
            pt = _ref[id];
            _results.push(id);
          }
          return _results;
        } else {
          return (_ref1 = []).concat.apply(_ref1, (function() {
            var _i, _len, _ref1, _results1;

            _ref1 = this.children;
            _results1 = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              c = _ref1[_i];
              _results1.push(c.approximateCircleQuery(centerPoint, radius, radiusSq));
            }
            return _results1;
          }).call(this));
        }
      } else {
        return [];
      }
    };

    return QTNode;

  })();

  ALWAYS_REPRODUCE = false;

  GeneCode = (function() {
    "The genes for a particular blob. This determines the stats and\nAI for the blob. The stats are Attack, Speed, Photosynthesis, and \nefficiency. The AI is structured as a neural net with the gene's \nenergy level and nearby observable objects as inputs, and with \npursue(object), flee(object), reproduce() as output nodes.\nThe blob will take the action with the signal that most exceeds\nits threshold, or no action if no signals exceed threshold";    GeneCode.copy = function(genecode) {
      var key, newGenes, oldGene, _ref;

      newGenes = {};
      _ref = genecode.genes;
      for (key in _ref) {
        oldGene = _ref[key];
        newGenes[key] = Gene.copy(oldGene);
      }
      return new GeneCode(newGenes);
    };

    function GeneCode(genes) {
      var atk_pho_total, spd_eff_total, _ref;

      this.genes = genes;
      if ((_ref = this.genes) == null) {
        this.genes = {
          atk: new Gene(null, 0, 100),
          spd: new Gene(null, 0, 100),
          pho: new Gene(null, 0, 100),
          eff: new Gene(null, 0, 100),
          red: new Gene(null, 0, 255, 1),
          grn: new Gene(null, 0, 255, 1),
          blu: new Gene(null, 0, 255, 1),
          huntBase: new Gene(null, -10000, 10000, 100),
          fleeBase: new Gene(null, -10000, 10000, 100),
          reprBase: new Gene(null, -10000, 10000, 100),
          huntMod: new Gene(),
          fleeMod: new Gene(),
          reprMod: new Gene(null, 0),
          nrgHunt: new Gene(),
          atkHunt: new Gene(),
          spdHunt: new Gene(),
          phoHunt: new Gene(),
          effHunt: new Gene(),
          dstHunt: new Gene(),
          clrHunt: new Gene(),
          nrgFlee: new Gene(),
          atkFlee: new Gene(),
          spdFlee: new Gene(),
          phoFlee: new Gene(),
          effFlee: new Gene(),
          dstFlee: new Gene(),
          clrFlee: new Gene(),
          childEnergy: new Gene(null, 0, 1000, 1)
        };
      }
      if (C.TWO_TRADEOFF) {
        atk_pho_total = this.genes.atk.val + this.genes.pho.val;
        spd_eff_total = this.genes.spd.val + this.genes.eff.val;
      } else {
        atk_pho_total = this.genes.atk.val + this.genes.pho.val + this.genes.spd.val + this.genes.eff.val;
        spd_eff_total = atk_pho_total;
      }
      this.atk = this.genes.atk.val / atk_pho_total * 100;
      this.pho = this.genes.pho.val / atk_pho_total * 100;
      this.spd = this.genes.spd.val / spd_eff_total * 100;
      this.eff = this.genes.eff.val / spd_eff_total * 100;
      this.red = this.genes.red.val;
      this.grn = this.genes.grn.val;
      this.blu = this.genes.blu.val;
    }

    GeneCode.prototype.chooseAction = function(energy, observables) {
      var action, actions, fleeAction, fleePairs, fleeSignal, fleeThreshold, huntAction, huntPairs, huntSignal, huntThreshold, maxAction, maxFlee, maxHunt, o, reprAction, reprSignal, reprThreshold, _ref, _ref1;

      if (ALWAYS_REPRODUCE) {
        return {
          "type": "repr",
          "argument": 0
        };
      }
      huntPairs = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = observables.length; _i < _len; _i++) {
          o = observables[_i];
          _results.push([this.calcHuntImpulse(o), o]);
        }
        return _results;
      }).call(this);
      fleePairs = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = observables.length; _i < _len; _i++) {
          o = observables[_i];
          _results.push([this.calcFleeImpulse(o), o]);
        }
        return _results;
      }).call(this);
      maxHunt = (_ref = maxByIndex(huntPairs, 0)) != null ? _ref : [0, null];
      maxFlee = (_ref1 = maxByIndex(fleePairs, 0)) != null ? _ref1 : [0, null];
      huntThreshold = this.genes.huntBase.val + this.genes.huntMod.val * energy;
      fleeThreshold = this.genes.fleeBase.val + this.genes.fleeMod.val * energy;
      reprThreshold = this.genes.reprBase.val + this.genes.reprMod.val * energy;
      huntSignal = this.genes.huntMod.val * energy + this.genes.huntBase.val + maxHunt[0];
      fleeSignal = this.genes.fleeMod.val * energy + this.genes.fleeBase.val + maxFlee[0];
      reprSignal = this.genes.reprMod.val * energy + this.genes.reprBase.val;
      fleeAction = [fleeSignal, 'flee', maxFlee[1]];
      huntAction = [huntSignal, 'hunt', maxHunt[1]];
      reprAction = [reprSignal, 'repr', this.genes.childEnergy.val];
      actions = [huntAction, fleeAction, reprAction];
      maxAction = maxByIndex(actions, 0);
      action = {
        "type": null
      };
      if (maxAction[0] > 0) {
        action.type = maxAction[1];
        action.argument = maxAction[2];
      }
      return action;
    };

    GeneCode.prototype.calcColorDist = function(b) {
      var dblu, dgrn, dred;

      dred = Math.abs(b.red - this.red);
      dgrn = Math.abs(b.grn - this.grn);
      dblu = Math.abs(b.blu - this.blu);
      return dred + dgrn + dblu - 10;
    };

    GeneCode.prototype.calcHuntImpulse = function(_arg) {
      var b, dist, i;

      b = _arg[0], dist = _arg[1];
      i = this.genes.nrgHunt.val * b.energy;
      i += this.genes.atkHunt.val * (b.atk - this.atk);
      i += this.genes.spdHunt.val * (b.spd - this.spd);
      i += this.genes.phoHunt.val * b.pho;
      i += this.genes.effHunt.val * b.eff;
      i += this.genes.dstHunt.val * dist;
      return i += this.genes.clrHunt.val * this.calcColorDist(b);
    };

    GeneCode.prototype.calcFleeImpulse = function(_arg) {
      var b, dist, i;

      b = _arg[0], dist = _arg[1];
      i = this.genes.nrgFlee.val * b.energy;
      i += this.genes.atkFlee.val * (b.atk - this.atk);
      i += this.genes.spdFlee.val * (b.spd - this.atk);
      i += this.genes.phoFlee.val * b.pho;
      i += this.genes.effFlee.val * b.eff;
      i += this.genes.dstFlee.val * dist;
      return i += this.genes.clrFlee.val * this.calcColorDist(b);
    };

    return GeneCode;

  })();

  Gene = (function() {
    "Represent a single gene in the GeneCode. Has method for mutation.\nIn future, plan to change so it references GeneCode and gets mutability\ninfo from GeneCode. Could be made more efficient by having GeneCodes with\nthe same Gene share references to the object.";    Gene.copy = function(old) {
      var newGene;

      newGene = new Gene(old.val, old.min, old.max, old.mutationSize);
      return newGene.mutate();
    };

    function Gene(val, min, max, mutationSize) {
      var _ref;

      this.val = val;
      this.min = min != null ? min : -100;
      this.max = max != null ? max : 100;
      this.mutationSize = mutationSize != null ? mutationSize : 5;
      if ((_ref = this.val) == null) {
        this.val = Math.random() * (this.max - this.min) + this.min;
      }
      this.mutationProbability = C.MUTATION_PROBABILITY;
    }

    Gene.prototype.mutate = function() {
      var mutationSize, sign;

      if (Math.random() < this.mutationProbability) {
        sign = randomSign();
        mutationSize = this.mutationSize * 2 * Math.random() * C.MUTATION_CONSTANT;
        this.val += sign * mutationSize;
        this.val = Math.max(this.val, this.min);
        this.val = Math.min(this.val, this.max);
      }
      return this;
    };

    return Gene;

  })();

  Blob = (function() {
    function Blob(environment, id, energy, geneCode) {
      var _ref;

      this.environment = environment;
      this.id = id;
      this.energy = energy != null ? energy : 0;
      this.geneCode = geneCode;
      this.age = 0;
      this.id += '';
      if ((_ref = this.geneCode) == null) {
        this.geneCode = new GeneCode();
      }
      this.pho = this.geneCode.pho;
      this.atk = this.geneCode.atk;
      this.spd = this.geneCode.spd;
      this.eff = this.geneCode.eff;
      this.red = this.geneCode.red;
      this.grn = this.geneCode.grn;
      this.blu = this.geneCode.blu;
      this.efficiencyFactor = 1 - (this.eff / 100) * .75;
      this.energyPerSecond = this.pho * (this.pho * C.PHO_SQ_EPS + C.PHO_EPS);
      this.energyPerSecond += (this.atk * (this.atk * C.ATK_SQ_EPS + C.ATK_EPS)) * this.efficiencyFactor;
      this.energyPerSecond += this.spd * C.SPD_EPS * this.efficiencyFactor;
      this.attackPower = this.atk * this.atk;
      this.currentHeading = null;
      this.maxMovement = this.spd * C.MOVEMENT_SPEED_FACTOR;
      this.rad = Math.sqrt(this.energy) * C.RADIUS_FACTOR + C.RADIUS_CONSTANT;
      this.radSq = this.rad * this.rad;
      this.stepsUntilNextAction = 0;
      this.stepsUntilNextQuery = 0;
      this.alive = true;
      this.movedLastTurn = 0;
      this.movedThisTurn = 0;
      this.neighborDists = {};
    }

    Blob.prototype.preStep = function() {
      "One full step of simulation for this blob.\nAttackables: Everything which is adjacent and close enough to \nauto-attack. These are passed by the environment";
      var n;

      this.attackedThisTurn = {};
      this.attackEnergyThisTurn = 0;
      this.numAttacks = 0;
      this.movedLastTurn = this.movedThisTurn;
      this.movedThisTurn = 0;
      this.energy += this.energyPerSecond;
      this.age++;
      this.energyPerSecond -= C.AGE_ENERGY_DECAY;
      this.energy *= 1 - C.ENERGY_DECAY;
      "Neighbors: Everything within seeing distance. Represented as\nlist of blobs. Querying only once every 10 steps, so force-recalc\ndistance for each neighbor everytime.";
      if (this.stepsUntilNextQuery <= 0) {
        this.neighbors = this.environment.getNeighbors(this.id);
        return this.stepsUntilNextQuery = 10;
      } else {
        this.neighbors = (function() {
          var _i, _len, _ref, _results;

          _ref = this.neighbors;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            if (n.alive) {
              _results.push(n);
            }
          }
          return _results;
        }).call(this);
        return this.stepsUntilNextQuery--;
      }
    };

    Blob.prototype.getObservables = function() {
      var dist, move_so_far, n, _base, _i, _j, _len, _len1, _name, _ref, _ref1, _ref2, _ref3, _results;

      _ref = this.neighbors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (this.neighborDists[n.id] != null) {
          _ref1 = this.neighborDists[n.id], dist = _ref1[0], move_so_far = _ref1[1];
          move_so_far += this.movedLastTurn + n.movedLastTurn;
          if (move_so_far > C.MOVE_UPDATE_AMT) {
            delete this.neighborDists[n.id];
          }
        }
        if ((_ref2 = (_base = this.neighborDists)[_name = n.id]) == null) {
          _base[_name] = [this.environment.blobDist(this, n), 0];
        }
      }
      _ref3 = this.neighbors;
      _results = [];
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        n = _ref3[_j];
        _results.push([n, this.neighborDists[n.id][0]]);
      }
      return _results;
    };

    Blob.prototype.chooseAction = function() {
      if (this.maintainCurrentAction > 0) {
        if (this.action.type === "hunt" && !this.environment.isAlive(this.huntTarget.id)) {
          this.maintainCurrentAction = 0;
        } else {
          this.maintainCurrentAction--;
          return;
        }
      }
      this.action = this.geneCode.chooseAction(this.energy, this.getObservables());
      if (this.action.type === "hunt") {
        if (this.huntTarget) {
          this.huntTarget = this.action.argument[0];
          this.maintainCurrentAction = 20;
        }
      }
      if (this.action.type === "repr") {
        this.maintainCurrentAction = C.REPR_TIME_REQUIREMENT;
        return this.reproducing = true;
      }
    };

    Blob.prototype.handleMovement = function() {
      var distance, heading, moveAmt, targetBlob, _ref, _ref1, _ref2;

      if (this.action.type === "hunt") {
        if (this.action.argument != null) {
          _ref = this.action.argument, targetBlob = _ref[0], distance = _ref[1];
          heading = this.environment.getHeading(this.id, targetBlob.id);
          moveAmt = distance - 3;
          this.wandering = null;
        } else {
          if ((_ref1 = this.wandering) == null) {
            this.wandering = Vector2D.randomHeading();
          }
          heading = this.wandering;
          moveAmt = this.maxMovement;
        }
      } else if (this.action.type === "flee" && (this.action.argument != null)) {
        _ref2 = this.action.argument, targetBlob = _ref2[0], distance = _ref2[1];
        heading = this.environment.getHeading(this.id, targetBlob.id);
        heading = Vector2D.negateHeading(heading);
        moveAmt = this.maxMovement;
        this.wandering = null;
      } else {
        this.wandering = null;
      }
      if ((heading != null) && (moveAmt != null)) {
        return this.move(heading, moveAmt);
      }
    };

    Blob.prototype.handleAttacks = function() {
      var aBlob, amt, attackDelta, dist, _i, _len, _ref, _ref1;

      _ref = this.getObservables();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], aBlob = _ref1[0], dist = _ref1[1];
        if (dist < this.rad + aBlob.rad + 1) {
          attackDelta = this.attackPower - aBlob.attackPower;
          if (attackDelta >= 0) {
            this.numAttacks++;
            aBlob.numAttacks++;
            amt = Math.min(attackDelta, aBlob.energy);
            this.energy += amt;
            this.attackEnergyThisTurn += amt;
            aBlob.energy -= attackDelta + 5;
            aBlob.attackEnergyThisTurn -= attackDelta + 5;
          }
        }
      }
      if (isNaN(this.attackEnergyThisTurn)) {
        console.log(this);
        return console.log("NAN attack energy");
      }
    };

    Blob.prototype.wrapUp = function() {
      if (this.action.type === "repr") {
        if (this.maintainCurrentAction === 0) {
          this.reproduce(this.action.argument);
          this.reproducing = null;
        }
      }
      this.rad = Math.sqrt(this.energy) * C.RADIUS_FACTOR + C.RADIUS_CONSTANT;
      this.radSq = this.rad * this.rad;
      if (this.energy < 0 || isNaN(this.energy)) {
        this.environment.removeBlob(this.id);
        return this.alive = false;
      }
    };

    Blob.prototype.move = function(heading, moveAmt) {
      moveAmt = Math.min(moveAmt, this.maxMovement, this.energy * C.MOVEMENT_PER_ENERGY / this.efficiencyFactor);
      moveAmt = Math.max(moveAmt, 0);
      this.energy -= moveAmt * this.efficiencyFactor / C.MOVEMENT_PER_ENERGY;
      this.environment.moveBlob(this.id, heading, moveAmt);
      this.neighborDists = {};
      return this.movedThisTurn = moveAmt;
    };

    Blob.prototype.reproduce = function(childEnergy) {
      var childGenes;

      if (this.energy <= C.REPR_ENERGY_COST) {
        this.energy -= C.REPR_ENERGY_COST / 2;
        return;
      }
      if (childEnergy > (this.energy - C.REPR_ENERGY_COST) / 2) {
        this.energy -= C.REPR_ENERGY_COST / 2;
        return;
      }
      if (this.energy >= childEnergy + C.REPR_ENERGY_COST * this.efficiencyFactor) {
        this.energy -= childEnergy + C.REPR_ENERGY_COST * this.efficiencyFactor;
        childGenes = GeneCode.copy(this.geneCode);
        return this.environment.addChildBlob(this.id, childEnergy, childGenes);
      }
    };

    return Blob;

  })();

  Environment = (function() {
    function Environment(starting_blobs, p) {
      var i, position, _i;

      this.p = p;
      this.blobs = {};
      this.qtree = new QuadTree(C.X_BOUND, C.Y_BOUND, C.QTREE_BUCKET_SIZE);
      this.location = this.qtree.id2point;
      this.nBlobs = 0;
      this.nextBlobId = 0;
      this.observedBlobID = null;
      for (i = _i = 0; 0 <= starting_blobs ? _i < starting_blobs : _i > starting_blobs; i = 0 <= starting_blobs ? ++_i : --_i) {
        position = Vector2D.randomVector(C.X_BOUND, C.Y_BOUND);
        this.addBlob(position, C.STARTING_ENERGY);
      }
    }

    Environment.prototype.observeBlob = function(xCoord, yCoord) {
      var b, clickLocation, nearbyBlobs, prevId, selected;

      console.log("Called observeBlob with " + xCoord + "," + yCoord);
      clickLocation = new Vector2D(xCoord, yCoord);
      if (this.observedBlob != null) {
        prevId = this.observedBlob.id;
        this.observedBlob.observed = null;
        this.observedBlob = null;
      }
      nearbyBlobs = this.getAdjacent(clickLocation, 80);
      nearbyBlobs = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = nearbyBlobs.length; _i < _len; _i++) {
          b = nearbyBlobs[_i];
          _results.push([b, clickLocation.distSq(this.location[b.id])]);
        }
        return _results;
      }).call(this);
      selected = minByIndex(nearbyBlobs, 1);
      if ((selected != null) && selected[1] < selected[0].rad + 10 && selected[0].id !== prevId) {
        selected = selected[0];
        this.observedBlob = selected;
        console.log("Observing blob:" + this.observedBlob.id);
        return this.observedBlob.observed = true;
      }
    };

    Environment.prototype.step = function() {
      var blob, id, _ref, _ref1, _ref2, _ref3, _results;

      this.qtree.rebuild();
      _ref = this.blobs;
      for (id in _ref) {
        blob = _ref[id];
        blob.preStep();
        blob.chooseAction();
      }
      _ref1 = this.blobs;
      for (id in _ref1) {
        blob = _ref1[id];
        blob.handleMovement();
      }
      _ref2 = this.blobs;
      for (id in _ref2) {
        blob = _ref2[id];
        blob.handleAttacks();
      }
      _ref3 = this.blobs;
      _results = [];
      for (id in _ref3) {
        blob = _ref3[id];
        _results.push(blob.wrapUp());
      }
      return _results;
    };

    Environment.prototype.getNeighbors = function(blobID) {
      var pos, rad;

      pos = this.location[blobID];
      rad = this.blobs[blobID].rad;
      return this.getAdjacent(pos, C.NEIGHBOR_DISTANCE + rad * 1.5, blobID);
    };

    Environment.prototype.getAdjacent = function(position, distance, blobID) {
      var otherID, queryResult, _i, _len, _results;

      queryResult = this.qtree.approximateCircleQuery(position, distance);
      _results = [];
      for (_i = 0, _len = queryResult.length; _i < _len; _i++) {
        otherID = queryResult[_i];
        if (otherID !== blobID) {
          _results.push(this.blobs[otherID]);
        }
      }
      return _results;
    };

    Environment.prototype.getHeading = function(sourceID, targetID) {
      var sourcePos, targetPos;

      sourcePos = this.location[sourceID];
      targetPos = this.location[targetID];
      return Vector2D.subtract(targetPos, sourcePos).heading();
    };

    Environment.prototype.moveBlob = function(blobID, heading, moveAmt) {
      var moveVector, newPos, sourcePos;

      sourcePos = this.location[blobID];
      moveVector = Vector2D.headingVector(heading).multiply(moveAmt);
      newPos = moveVector.add(sourcePos);
      newPos.wrapToBound(C.X_BOUND, C.Y_BOUND);
      return this.qtree.moveObject(blobID, newPos);
    };

    Environment.prototype.addBlob = function(position, energy, geneCode) {
      var b;

      b = new Blob(this, this.nextBlobId, energy, geneCode);
      this.blobs[this.nextBlobId] = b;
      this.qtree.addObject(this.nextBlobId, position);
      this.nextBlobId++;
      return this.nBlobs++;
    };

    Environment.prototype.addChildBlob = function(parentID, childEnergy, childGenes) {
      var childOffset, childPosition, parentPosition, parentRadius, parentSpeed;

      parentPosition = this.location[parentID];
      parentRadius = this.blobs[parentID].rad;
      parentSpeed = this.blobs[parentID].spd;
      childOffset = Vector2D.randomUnitVector();
      childOffset.multiply(C.CHILD_DISTANCE + parentRadius + parentSpeed / 2);
      childPosition = childOffset.add(parentPosition);
      childPosition.wrapToBound(C.X_BOUND, C.Y_BOUND);
      return this.addBlob(childPosition, childEnergy, childGenes);
    };

    Environment.prototype.removeBlob = function(blobID) {
      if ((this.observedBlob != null) && this.observedBlob.id === blobID) {
        this.observedBlob = null;
      }
      delete this.blobs[blobID];
      this.qtree.removeObject(blobID);
      return this.nBlobs--;
    };

    Environment.prototype.isAlive = function(blobID) {
      return blobID in this.blobs;
    };

    Environment.prototype.blobDistSq = function(blob1, blob2) {
      var p1, p2;

      p1 = this.location[blob1.id];
      p2 = this.location[blob2.id];
      return p1.distSq(p2);
    };

    Environment.prototype.blobDist = function(blob1, blob2) {
      return Math.sqrt(this.blobDistSq(blob1, blob2));
    };

    return Environment;

  })();

  InfoArea = (function() {
    function InfoArea(p, e) {
      this.p = p;
      this.e = e;
    }

    InfoArea.prototype.draw = function() {
      this.p.pushMatrix();
      this.p.translate(0, C.DISPLAY_Y);
      this.makeRect();
      this.blob = this.e.observedBlob;
      if (this.blob != null) {
        this.printInfo(this.blob);
      }
      return this.p.popMatrix();
    };

    InfoArea.prototype.makeRect = function() {
      this.p.strokeWeight(6);
      this.p.stroke(0);
      this.p.fill(15);
      this.p.rect(0, 0, C.DISPLAY_X, C.DISPLAY_BOUND);
      return this.p.noStroke();
    };

    InfoArea.prototype.printInfo = function(blob) {
      var attackInfo, geneStats, otherStats;

      this.offset = 0;
      this.p.fill(255);
      geneStats = "ATK: " + (this.fmt(blob.atk)) + " SPD: " + (this.fmt(blob.spd)) + " PHO: " + (this.fmt(blob.pho)) + " EFF: " + (this.fmt(blob.eff));
      otherStats = "Energy: " + (this.fmt(blob.energy)) + " Age: " + (this.fmt(blob.age)) + " EPS: " + (this.fmt(blob.energyPerSecond)) + " Attack Power: " + (this.fmt(blob.attackPower));
      attackInfo = "Attacked " + (this.fmt(blob.numAttacks)) + ", total " + (this.fmt(blob.attackEnergyThisTurn)) + " energy xfer";
      this.writeLine(geneStats);
      this.writeLine(otherStats);
      this.writeLine(attackInfo);
      return this.writeAction(blob);
    };

    InfoArea.prototype.writeAction = function(blob) {
      var action, argument;

      action = blob.action;
      if (action.type === "flee" || action.type === "hunt") {
        if (action.argument != null) {
          argument = action.argument[0].id;
        } else {
          argument = "none";
        }
      } else if (action.type === "repr") {
        argument = this.fmt(action.argument);
      } else {
        argument = "none";
      }
      return this.writeLine("Action: " + action.type + ", Argument: " + argument);
    };

    InfoArea.prototype.writeLine = function(s) {
      this.offset += 20;
      return this.p.text(s, 10, this.offset);
    };

    InfoArea.prototype.fmt = function(num) {
      return Math.round(num);
    };

    return InfoArea;

  })();

  Simulation = (function() {
    function Simulation(p) {
      this.p = p;
      this.env = new Environment(C.STARTING_BLOBS, p);
      this.running = true;
      if (C.INFO_WINDOW) {
        this.infoArea = new InfoArea(this.p, this.env);
      }
      this.xLower = 100;
      this.yLower = 100;
      this.xUpper = 100 + C.DISPLAY_X;
      this.yUpper = 100 + C.DISPLAY_Y;
      this.showNucleus = false;
      this.showShells = false;
      this.showReproduction = false;
    }

    Simulation.prototype.step = function() {
      if (this.running) {
        this.env.step();
        return this.drawAll();
      }
    };

    Simulation.prototype.keyCode = function(k) {
      if (k === 32) {
        this.running = !this.running;
      }
      if (k === 78) {
        this.showNucleus = !this.showNucleus;
      }
      if (k === 83) {
        this.showShells = !this.showShells;
      }
      if (k === 82) {
        return this.showReproduction = !this.showReproduction;
      }
    };

    Simulation.prototype.mouseClick = function(x, y) {
      if (C.INFO_WINDOW) {
        this.env.observeBlob(x + 100, y + 100);
        if (!this.running) {
          return this.drawAll();
        }
      }
    };

    Simulation.prototype.drawAll = function() {
      var blob, blobID, pos, _ref;

      this.p.background(0);
      _ref = this.env.blobs;
      for (blobID in _ref) {
        blob = _ref[blobID];
        pos = this.env.qtree.id2point[blobID];
        this.drawBlob(blob, pos);
      }
      if (C.INFO_WINDOW) {
        return this.infoArea.draw();
      }
    };

    Simulation.prototype.drawBlob = function(blob, position) {
      var blu, blu2, grn, grn2, intersectX, intersectY, nuc_blu, nuc_grn, nuc_red, r, rad, red, red2, weight, x, y;

      r = blob.rad;
      x = position.x;
      y = position.y;
      intersectX = x + r > this.xLower || x - r < this.xUpper;
      intersectY = y + r > this.yLower || y - r < this.yUpper;
      if (intersectX && intersectY) {
        x -= this.xLower;
        y -= this.yLower;
        this.p.noStroke();
        red = blob.atk * 2.55;
        grn = blob.pho * 2.55;
        blu = blob.spd * 2.55;
        this.p.fill(red, grn, blu);
        if (blob.observed != null) {
          this.p.strokeWeight(1);
          this.p.stroke(255);
        }
        this.p.ellipse(x, y, 2 * r, 2 * r);
        if (this.showNucleus) {
          nuc_red = blob.red;
          nuc_grn = blob.grn;
          nuc_blu = blob.blu;
          this.p.fill(nuc_red, nuc_grn, nuc_blu);
          rad = Math.min(3, blob.rad / 2);
          this.p.ellipse(x, y, 2 * rad, 2 * rad);
        }
        if (this.showShells) {
          nuc_red = blob.red;
          nuc_grn = blob.grn;
          nuc_blu = blob.blu;
          this.p.stroke(nuc_red, nuc_grn, nuc_blu);
          this.p.noFill();
          rad = blob.rad;
          this.p.strokeWeight(2);
          this.p.ellipse(x, y, 2 * rad, 2 * rad);
        }
        if (this.showReproduction && (blob.reproducing != null)) {
          red2 = Math.min(red + 9, 255);
          grn2 = Math.min(grn + 9, 255);
          blu2 = Math.min(blu + 9, 255);
          this.p.noFill();
          this.p.stroke(red2, grn2, blu2);
          weight = 5 * (C.REPR_TIME_REQUIREMENT - blob.maintainCurrentAction) / C.REPR_TIME_REQUIREMENT;
          this.p.strokeWeight(weight);
          return this.p.ellipse(x, y, 2 * r - 5, 2 * r - 5);
        }
      }
    };

    return Simulation;

  })();

  simulator_draw = function(p) {
    var s;

    s = new Simulation(p);
    p.mouseClicked = function() {
      return s.mouseClick(p.mouseX, p.mouseY);
    };
    p.setup = function() {
      p.frameRate(C.FRAME_RATE);
      p.size(C.DISPLAY_X, C.DISPLAY_Y + C.DISPLAY_BOUND);
      return p.background(0, 20, 90);
    };
    p.draw = function() {
      return s.step();
    };
    return p.keyPressed = function() {
      console.log(p.keyCode);
      return s.keyCode(p.keyCode);
    };
  };

  $(document).ready(function() {
    var canvas, processing;

    canvas = document.getElementById("processing");
    return processing = new Processing(canvas, simulator_draw);
  });

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var ALWAYS_REPRODUCE, Blob, Gene, GeneCode, QTNode, QuadTree, Simulation, Vector2D, maxByIndex, minByIndex, randomSign, sim;

  randomSign = function() {
    if (Math.random() > .5) {
      return 1;
    } else {
      return -1;
    }
  };

  maxByIndex = function(arrayOfArrays, index) {
    "Get the maximum Array in an Array of Arrays according to \nordering by one of the indexes\ne.g. maxByElem [[\"hello\", 1], [\"goodbye\", 2]], 1 -> [\"goodbye\", 2]";
    var arr, j, len, maxArray, maxIndex;
    if (!arrayOfArrays.length) {
      return null;
    }
    maxIndex = arrayOfArrays[0][index];
    maxArray = arrayOfArrays[0];
    for (j = 0, len = arrayOfArrays.length; j < len; j++) {
      arr = arrayOfArrays[j];
      if (arr[index] > maxIndex) {
        maxIndex = arr[index];
        maxArray = arr;
      }
    }
    if (maxIndex == null) {
      throw new Error("maxByIndex: Index out of bounds for entire array");
    }
    return maxArray;
  };

  minByIndex = function(arrayOfArrays, index) {
    "Get the minimum Array in an Array of Arrays according to \nordering by one of the indexes\ne.g. minByElem [[\"hello\", 1], [\"goodbye\", 2]], 1 -> [\"goodbye\", 2]";
    var arr, j, len, minArray, minIndex;
    if (!arrayOfArrays.length) {
      return null;
    }
    minIndex = arrayOfArrays[0][index];
    minArray = arrayOfArrays[0];
    for (j = 0, len = arrayOfArrays.length; j < len; j++) {
      arr = arrayOfArrays[j];
      if (arr[index] < minIndex) {
        minIndex = arr[index];
        minArray = arr;
      }
    }
    if (minIndex == null) {
      throw new Error("minByIndex: Index out of bounds for entire array");
    }
    return minArray;
  };

  Math.PI2 = 2 * Math.PI;

  Vector2D = (function() {
    var fn, j, len, name, ref;

    ref = ['add', 'subtract', 'multiply', 'divide'];
    fn = function(name) {
      return Vector2D[name] = function(a, b) {
        return a.copy()[name](b);
      };
    };
    for (j = 0, len = ref.length; j < len; j++) {
      name = ref[j];
      fn(name);
    }

    Vector2D.randomUnitVector = function() {
      var v;
      v = new Vector2D(Math.random() - .5, Math.random() - .5);
      return v.normalize();
    };

    Vector2D.randomVector = function(xMax, yMax) {
      return new Vector2D(Math.random() * xMax, Math.random() * yMax);
    };

    Vector2D.randomBoundedVector = function(xMin, xMax, yMin, yMax) {
      var v;
      v = Vector2D.randomVector(xMax - xMin, yMax - yMin);
      return v.add(new Vector2D(xMin, yMin));
    };

    Vector2D.randomHeading = function() {
      return Math.random() * Math.PI2;
    };

    Vector2D.negateHeading = function(h) {
      return (h + Math.PI) % Math.PI2;
    };

    Vector2D.headingVector = function(h) {
      return new Vector2D(Math.cos(h), Math.sin(h));
    };

    function Vector2D(x, y) {
      var ref1;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      ref1 = [x, y], this.x = ref1[0], this.y = ref1[1];
    }

    Vector2D.prototype.copy = function() {
      return new Vector2D(this.x, this.y);
    };

    Vector2D.prototype.magnitude = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    Vector2D.prototype.normalize = function() {
      var m;
      m = this.magnitude();
      if (m > 0) {
        this.divide(m);
      }
      return this;
    };

    Vector2D.prototype.limit = function(max) {
      if (this.magnitude() > max) {
        this.normalize();
        return this.multiply(max);
      } else {
        return this;
      }
    };

    Vector2D.prototype.heading = function() {
      return (Math.atan2(this.y, this.x) + Math.PI2) % Math.PI2;
    };

    Vector2D.prototype.eucl_distance = function(other) {
      var dx, dy;
      dx = this.x - other.x;
      dy = this.y - other.y;
      return Math.sqrt(dx * dx + dy * dy);
    };

    Vector2D.prototype.distSq = function(other) {
      var dx, dy;
      dx = this.x - other.x;
      dy = this.y - other.y;
      return dx * dx + dy * dy;
    };

    Vector2D.prototype.distance = function(other, dimensions) {
      var dx, dy;
      if (dimensions == null) {
        dimensions = false;
      }
      dx = Math.abs(this.x - other.x);
      dy = Math.abs(this.y - other.y);
      if (dimensions) {
        dx = dx < dimensions.width / 2 ? dx : dimensions.width - dx;
        dy = dy < dimensions.height / 2 ? dy : dimensions.height - dy;
      }
      return Math.sqrt(dx * dx + dy * dy);
    };

    Vector2D.prototype.subtract = function(other) {
      this.x -= other.x;
      this.y -= other.y;
      return this;
    };

    Vector2D.prototype.add = function(other) {
      this.x += other.x;
      this.y += other.y;
      return this;
    };

    Vector2D.prototype.divide = function(n) {
      var ref1;
      ref1 = [this.x / n, this.y / n], this.x = ref1[0], this.y = ref1[1];
      return this;
    };

    Vector2D.prototype.multiply = function(n) {
      var ref1;
      ref1 = [this.x * n, this.y * n], this.x = ref1[0], this.y = ref1[1];
      return this;
    };

    Vector2D.prototype.dot = function(other) {
      return this.x * other.x + this.y * other.y;
    };

    Vector2D.prototype.projectOnto = function(other) {
      return other.copy().multiply(this.dot(other));
    };

    Vector2D.prototype.wrapToBound = function(xBound, yBound) {
      this.x = (this.x + xBound) % xBound;
      return this.y = (this.y + yBound) % yBound;
    };

    Vector2D.prototype.constrainToBound = function(xBound, yBound) {
      if (this.x < 0) {
        this.x = 0;
      }
      if (this.x > xBound) {
        this.x = xBound;
      }
      if (this.y < 0) {
        this.y = 0;
      }
      if (this.y > yBound) {
        return this.y = yBound;
      }
    };

    Vector2D.prototype.wrapRelativeTo = function(location, dimensions) {
      var a, d, key, map_d, ref1, v;
      v = this.copy();
      ref1 = {
        x: "width",
        y: "height"
      };
      for (a in ref1) {
        key = ref1[a];
        d = this[a] - location[a];
        map_d = dimensions[key];
        if (Math.abs(d) > map_d / 2) {
          if (d > 0) {
            v[a] = (map_d - this[a]) * -1;
          } else {
            v[a] = this[a] + map_d;
          }
        }
      }
      return v;
    };

    Vector2D.prototype.invalid = function() {
      return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y);
    };

    return Vector2D;

  })();

  QuadTree = (function() {
    "Maintain a QuadTree of objects on a 2D space.\nEach object is represented by a unique id and has an associated 2D point.\nMaps from IDs to Vector2D points, and back.\nPoints do not uniquely identify an Id,Point combo because\nmultiple IDs may share the same location. IDs\nmust be unique.\nNOTE: QuadTree may break if >bucketSize points have exact same coordinate\nSuggest fixing by adding tiny random disturbance to avoid this situation";
    function QuadTree(xBound1, yBound1, bucketSize) {
      this.xBound = xBound1;
      this.yBound = yBound1;
      this.bucketSize = bucketSize;
      this.id2point = {};
      this.numPoints = 0;
      this.tree = new QTNode(this.xBound / 2, this.yBound / 2, this.xBound / 2, this.yBound / 2, this.bucketSize);
    }

    QuadTree.prototype.addObject = function(id, point) {
      var ref, ref1;
      if (!((0 <= (ref = point.x) && ref <= this.xBound) && (0 <= (ref1 = point.y) && ref1 <= this.yBound))) {
        throw new Error("Index out of bounds: " + point.x + ", " + point.y);
      }
      if (id in this.id2point) {
        throw Error("Object ID collision on id: " + id);
      }
      this.id2point[id] = point;
      this.tree.addPoint(id, point);
      return ++this.numPoints;
    };

    QuadTree.prototype.removeObject = function(id) {
      var p;
      if (!(id in this.id2point)) {
        throw Error("Tried to remove ID that isn't in map");
      }
      p = this.id2point[id];
      this.tree.removePoint(id, p);
      delete this.id2point[id];
      return --this.numPoints;
    };

    QuadTree.prototype.moveObject = function(id, newPoint) {
      this.removeObject(id);
      return this.addObject(id, newPoint);
    };

    QuadTree.prototype.calculateDistance = function(id1, id2) {
      var p1, p2;
      p1 = this.id2point[id1];
      p2 = this.id2point[id2];
      return p1.eucl_distance(p2);
    };

    QuadTree.prototype.circleQuery = function(centerPoint, radius) {
      "Returns a list of all object IDs that fall within the circle";
      return this.tree.circleQuery(centerPoint, radius, radius * radius);
    };

    QuadTree.prototype.approximateCircleQuery = function(centerPoint, radius) {
      "Returns a list of all object IDs that fall in nodes that intersect the circle";
      return this.tree.approximateCircleQuery(centerPoint, radius, radius * radius);
    };

    QuadTree.prototype.rebuild = function() {
      var id, oldPoints, pt, results;
      this.tree = new QTNode(this.xBound / 2, this.yBound / 2, this.xBound / 2, this.yBound / 2, this.bucketSize);
      oldPoints = this.id2point;
      this.id2point = {};
      results = [];
      for (id in oldPoints) {
        pt = oldPoints[id];
        results.push(this.addObject(id, pt));
      }
      return results;
    };

    QuadTree.prototype.resize = function(xBound1, yBound1) {
      this.xBound = xBound1;
      this.yBound = yBound1;
      return this.rebuild();
    };

    return QuadTree;

  })();

  QTNode = (function() {
    function QTNode(x1, y1, xEdge, yEdge, bucketSize, depth) {
      var MM, MP, PM, PP;
      this.x = x1;
      this.y = y1;
      this.xEdge = xEdge;
      this.yEdge = yEdge;
      this.bucketSize = bucketSize;
      this.depth = depth != null ? depth : 0;
      this.leaf = true;
      this.points = {};
      this.nPoints = 0;
      MM = new Vector2D(this.x - this.xEdge, this.y - this.yEdge);
      MP = new Vector2D(this.x - this.xEdge, this.y + this.yEdge);
      PM = new Vector2D(this.x + this.xEdge, this.y - this.yEdge);
      PP = new Vector2D(this.x + this.xEdge, this.y + this.yEdge);
      this.corners = [MM, MP, PM, PP];
    }

    QTNode.prototype.addPoint = function(id, p) {
      var id_, idx, p_, pts, results;
      this.nPoints++;
      this.points[id] = p;
      if (this.leaf) {
        if (this.nPoints > this.bucketSize) {
          this.leaf = false;
          this.createChildren();
          this.nPoints = 0;
          pts = this.points;
          this.points = {};
          results = [];
          for (id_ in pts) {
            p_ = pts[id_];
            results.push(this.addPoint(id_, p_));
          }
          return results;
        }
      } else {
        idx = 2 * (p.x > this.x) + (p.y > this.y);
        return this.children[idx].addPoint(id, p);
      }
    };

    QTNode.prototype.createChildren = function() {
      var MM, MP, PM, PP, newXEdge, newYEdge;
      if (this.children != null) {
        throw new Error("Non-leaf node tried to make children");
      }
      newXEdge = this.xEdge / 2;
      newYEdge = this.yEdge / 2;
      if (this.depth > 4000) {
        self.postDebug(this.points);
      }
      MM = new QTNode(this.x - newXEdge, this.y - newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
      MP = new QTNode(this.x - newXEdge, this.y + newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
      PM = new QTNode(this.x + newXEdge, this.y - newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
      PP = new QTNode(this.x + newXEdge, this.y + newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
      return this.children = [MM, MP, PM, PP];
    };

    QTNode.prototype.removePoint = function(id, p) {
      var idx;
      if (!(id in this.points)) {
        throw new Error("Tried to remove id not in QTNode");
      }
      delete this.points[id];
      --this.nPoints;
      if (!this.leaf) {
        idx = 2 * (p.x > this.x) + (p.y > this.y);
        return this.children[idx].removePoint(id, p);
      }
    };

    QTNode.prototype.nearbyPoints = function(centerPoint, maxDist) {
      var distSq, grandparent, id, idx, parent, pt, pts, ref, ref1, results;
      if (this.leaf) {
        distSq = maxDist * maxDist;
        parent = (ref = this.parent) != null ? ref : this;
        grandparent = (ref1 = parent.parent) != null ? ref1 : parent;
        pts = grandparent.points;
        results = [];
        for (id in pts) {
          pt = pts[id];
          if (centerPoint.distSq(pt) <= distSq) {
            results.push(id);
          }
        }
        return results;
      } else {
        idx = 2 * (centerPoint.x > this.x) + (centerPoint.y > this.y);
        return this.children[idx].nearbyPoints(centerPoint, maxDist);
      }
    };

    QTNode.prototype.circleQuery = function(centerPoint, radius, radiusSq) {
      var c, id, intersect, minDist2Corner, pt, ref, ref1, results, xDist, yDist;
      intersect = false;
      xDist = Math.abs(centerPoint.x - this.x);
      yDist = Math.abs(centerPoint.y - this.y);
      intersect || (intersect = xDist <= this.xEdge && yDist <= this.yEdge + radius);
      intersect || (intersect = yDist <= this.yEdge && xDist <= this.xEdge + radius);
      minDist2Corner = Math.min.apply(Math, (function() {
        var j, len, ref, results;
        ref = this.corners;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          results.push(centerPoint.distSq(c));
        }
        return results;
      }).call(this));
      intersect || (intersect = minDist2Corner <= radiusSq);
      if (intersect) {
        if (this.leaf) {
          ref = this.points;
          results = [];
          for (id in ref) {
            pt = ref[id];
            if (centerPoint.distSq(pt) <= radiusSq) {
              results.push(id);
            }
          }
          return results;
        } else {
          return (ref1 = []).concat.apply(ref1, (function() {
            var j, len, ref1, results1;
            ref1 = this.children;
            results1 = [];
            for (j = 0, len = ref1.length; j < len; j++) {
              c = ref1[j];
              results1.push(c.circleQuery(centerPoint, radius, radiusSq));
            }
            return results1;
          }).call(this));
        }
      } else {
        return [];
      }
    };

    QTNode.prototype.approximateCircleQuery = function(centerPoint, radius, radiusSq) {
      var c, id, intersect, minDist2Corner, pt, ref, ref1, results, xDist, yDist;
      intersect = false;
      xDist = Math.abs(centerPoint.x - this.x);
      yDist = Math.abs(centerPoint.y - this.y);
      intersect || (intersect = xDist <= this.xEdge && yDist <= this.yEdge + radius);
      intersect || (intersect = yDist <= this.yEdge && xDist <= this.xEdge + radius);
      minDist2Corner = Math.min.apply(Math, (function() {
        var j, len, ref, results;
        ref = this.corners;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          results.push(centerPoint.distSq(c));
        }
        return results;
      }).call(this));
      intersect || (intersect = minDist2Corner <= radiusSq);
      if (intersect) {
        if (this.leaf) {
          ref = this.points;
          results = [];
          for (id in ref) {
            pt = ref[id];
            results.push(id);
          }
          return results;
        } else {
          return (ref1 = []).concat.apply(ref1, (function() {
            var j, len, ref1, results1;
            ref1 = this.children;
            results1 = [];
            for (j = 0, len = ref1.length; j < len; j++) {
              c = ref1[j];
              results1.push(c.approximateCircleQuery(centerPoint, radius, radiusSq));
            }
            return results1;
          }).call(this));
        }
      } else {
        return [];
      }
    };

    return QTNode;

  })();

  ALWAYS_REPRODUCE = false;

  GeneCode = (function() {
    "The genes for a particular blob. This determines the stats and\nAI for the blob. The stats are Attack, Speed, Photosynthesis, and \nefficiency. The AI is structured as a neural net with the gene's \nenergy level and nearby observable objects as inputs, and with \npursue(object), flee(object), reproduce() as output nodes.\nThe blob will take the action with the signal that most exceeds\nits threshold, or no action if no signals exceed threshold";
    GeneCode.copy = function(genecode) {
      var key, newGenes, oldGene, ref;
      newGenes = {};
      ref = genecode.genes;
      for (key in ref) {
        oldGene = ref[key];
        newGenes[key] = Gene.copy(oldGene);
      }
      return new GeneCode(newGenes);
    };

    function GeneCode(genes) {
      var atk_pho_total, spd_eff_total;
      this.genes = genes;
      if (this.genes == null) {
        this.genes = {
          atk: new Gene(null, 0, 100),
          spd: new Gene(null, 0, 100),
          pho: new Gene(null, 0, 100),
          eff: new Gene(null, 0, 100),
          red: new Gene(null, 0, 255, 1),
          grn: new Gene(null, 0, 255, 1),
          blu: new Gene(null, 0, 255, 1),
          huntBase: new Gene(null, -10000, 10000, 100),
          fleeBase: new Gene(null, -10000, 10000, 100),
          reprBase: new Gene(null, -10000, 10000, 100),
          huntMod: new Gene(),
          fleeMod: new Gene(),
          reprMod: new Gene(null, 0),
          nrgHunt: new Gene(),
          atkHunt: new Gene(),
          spdHunt: new Gene(),
          phoHunt: new Gene(),
          effHunt: new Gene(),
          dstHunt: new Gene(),
          clrHunt: new Gene(),
          nrgFlee: new Gene(),
          atkFlee: new Gene(),
          spdFlee: new Gene(),
          phoFlee: new Gene(),
          effFlee: new Gene(),
          dstFlee: new Gene(),
          clrFlee: new Gene(),
          childEnergy: new Gene(null, 0, 1000, 1)
        };
      }
      if (self.C.TWO_TRADEOFF) {
        atk_pho_total = this.genes.atk.val + this.genes.pho.val;
        spd_eff_total = this.genes.spd.val + this.genes.eff.val;
      } else {
        atk_pho_total = this.genes.atk.val + this.genes.pho.val + this.genes.spd.val + this.genes.eff.val;
        spd_eff_total = atk_pho_total;
      }
      this.atk = this.genes.atk.val / atk_pho_total * 100;
      this.pho = this.genes.pho.val / atk_pho_total * 100;
      this.spd = this.genes.spd.val / spd_eff_total * 100;
      this.eff = this.genes.eff.val / spd_eff_total * 100;
      this.red = this.genes.red.val;
      this.grn = this.genes.grn.val;
      this.blu = this.genes.blu.val;
    }

    GeneCode.prototype.chooseAction = function(energy, observables) {
      var action, actions, fleeAction, fleePairs, fleeSignal, fleeThreshold, huntAction, huntPairs, huntSignal, huntThreshold, maxAction, maxFlee, maxHunt, o, ref, ref1, reprAction, reprSignal, reprThreshold;
      if (ALWAYS_REPRODUCE) {
        return {
          "type": "repr",
          "argument": 0
        };
      }
      huntPairs = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = observables.length; j < len; j++) {
          o = observables[j];
          results.push([this.calcHuntImpulse(o), o]);
        }
        return results;
      }).call(this);
      fleePairs = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = observables.length; j < len; j++) {
          o = observables[j];
          results.push([this.calcFleeImpulse(o), o]);
        }
        return results;
      }).call(this);
      maxHunt = (ref = maxByIndex(huntPairs, 0)) != null ? ref : [0, null];
      maxFlee = (ref1 = maxByIndex(fleePairs, 0)) != null ? ref1 : [0, null];
      huntThreshold = this.genes.huntBase.val + this.genes.huntMod.val * energy;
      fleeThreshold = this.genes.fleeBase.val + this.genes.fleeMod.val * energy;
      reprThreshold = this.genes.reprBase.val + this.genes.reprMod.val * energy;
      huntSignal = this.genes.huntMod.val * energy + this.genes.huntBase.val + maxHunt[0];
      fleeSignal = this.genes.fleeMod.val * energy + this.genes.fleeBase.val + maxFlee[0];
      reprSignal = this.genes.reprMod.val * energy + this.genes.reprBase.val;
      fleeAction = [fleeSignal, 'flee', maxFlee[1]];
      huntAction = [huntSignal, 'hunt', maxHunt[1]];
      reprAction = [reprSignal, 'repr', this.genes.childEnergy.val];
      actions = [huntAction, fleeAction, reprAction];
      maxAction = maxByIndex(actions, 0);
      action = {
        "type": null
      };
      if (maxAction[0] > 0) {
        action.type = maxAction[1];
        action.argument = maxAction[2];
      }
      return action;
    };

    GeneCode.prototype.calcColorDist = function(b) {
      var dblu, dgrn, dred;
      dred = Math.abs(b.red - this.red);
      dgrn = Math.abs(b.grn - this.grn);
      dblu = Math.abs(b.blu - this.blu);
      return dred + dgrn + dblu - 10;
    };

    GeneCode.prototype.calcHuntImpulse = function(arg) {
      var b, dist, i;
      b = arg[0], dist = arg[1];
      i = this.genes.nrgHunt.val * b.energy;
      i += this.genes.atkHunt.val * (b.atk - this.atk);
      i += this.genes.spdHunt.val * (b.spd - this.spd);
      i += this.genes.phoHunt.val * b.pho;
      i += this.genes.effHunt.val * b.eff;
      i += this.genes.dstHunt.val * dist;
      return i += this.genes.clrHunt.val * this.calcColorDist(b);
    };

    GeneCode.prototype.calcFleeImpulse = function(arg) {
      var b, dist, i;
      b = arg[0], dist = arg[1];
      i = this.genes.nrgFlee.val * b.energy;
      i += this.genes.atkFlee.val * (b.atk - this.atk);
      i += this.genes.spdFlee.val * (b.spd - this.atk);
      i += this.genes.phoFlee.val * b.pho;
      i += this.genes.effFlee.val * b.eff;
      i += this.genes.dstFlee.val * dist;
      return i += this.genes.clrFlee.val * this.calcColorDist(b);
    };

    return GeneCode;

  })();

  Gene = (function() {
    "Represent a single gene in the GeneCode. Has method for mutation.\nIn future, plan to change so it references GeneCode and gets mutability\ninfo from GeneCode. Could be made more efficient by having GeneCodes with\nthe same Gene share references to the object.";
    Gene.copy = function(old) {
      var newGene;
      newGene = new Gene(old.val, old.min, old.max, old.mutationSize);
      return newGene.mutate();
    };

    function Gene(val, min, max1, mutationSize1) {
      this.val = val;
      this.min = min != null ? min : -100;
      this.max = max1 != null ? max1 : 100;
      this.mutationSize = mutationSize1 != null ? mutationSize1 : 5;
      if (this.val == null) {
        this.val = Math.random() * (this.max - this.min) + this.min;
      }
      this.mutationProbability = self.C.MUTATION_PROBABILITY;
    }

    Gene.prototype.mutate = function() {
      var mutationSize, sign;
      if (Math.random() < this.mutationProbability) {
        sign = randomSign();
        mutationSize = this.mutationSize * 2 * Math.random() * self.C.MUTATION_CONSTANT;
        this.val += sign * mutationSize;
        this.val = Math.max(this.val, this.min);
        this.val = Math.min(this.val, this.max);
      }
      return this;
    };

    return Gene;

  })();

  Blob = (function() {
    function Blob(simulation, id3, energy1, geneCode1, pos1) {
      this.simulation = simulation;
      this.id = id3;
      this.energy = energy1 != null ? energy1 : 0;
      this.geneCode = geneCode1;
      this.pos = pos1;
      this.age = 0;
      this.id += '';
      if (this.geneCode == null) {
        this.geneCode = new GeneCode();
      }
      this.pho = this.geneCode.pho;
      this.atk = this.geneCode.atk;
      this.spd = this.geneCode.spd;
      this.eff = this.geneCode.eff;
      this.red = this.atk * 2.55;
      this.grn = this.pho * 2.55;
      this.blu = this.spd * 2.55;
      this.currentHeading = null;
      this.maxMovement = this.spd * self.C.MOVEMENT_SPEED_FACTOR;
      this.reproSpeedFactor = (100 - this.spd) / 100;
      this.stepsUntilNextAction = 0;
      this.stepsUntilNextQuery = 0;
      this.alive = true;
      this.neighborDists = {};
      this.calculateEnergyAndRadius();
    }

    Blob.prototype.calculateEnergyAndRadius = function() {
      this.efficiencyFactor = 1 - (this.eff / 100) * .75;
      this.energyPerSecond = this.pho * (this.pho * self.C.PHO_SQ_EPS + self.C.PHO_EPS);
      this.energyPerSecond -= (this.atk * (this.atk * self.C.ATK_SQ_EPS + self.C.ATK_EPS)) * this.efficiencyFactor;
      this.energyPerSecond += this.spd * self.C.SPD_EPS * this.efficiencyFactor;
      this.energyPerSecond -= self.C.AGE_ENERGY_DECAY * this.age * this.age;
      this.attackPower = this.atk * this.atk;
      return this.calculateRadius();
    };

    Blob.prototype.calculateRadius = function() {
      this.rad = Math.sqrt(this.energy) * self.C.RADIUS_FACTOR + self.C.RADIUS_CONSTANT;
      return this.rad *= self.C.BLOB_SIZE;
    };

    Blob.prototype.preStep = function() {
      "One full step of simulation for this blob.\nAttackables: Everything which is adjacent and close enough to\nauto-attack. These are passed by the simulation";
      var n;
      this.attackedThisTurn = {};
      this.attackEnergyThisTurn = 0;
      this.numAttacks = 0;
      this.movedLastTurn = this.movedThisTurn;
      this.movedThisTurn = 0;
      this.energy += this.energyPerSecond;
      this.age++;
      this.energy *= 1 - self.C.ENERGY_DECAY;
      "Neighbors: Everything within seeing distance. Represented as\nlist of blobs. Querying only once every 10 steps, so force-recalc\ndistance for each neighbor everytime.";
      if (this.stepsUntilNextQuery <= 0) {
        this.neighbors = this.simulation.getNeighbors(this.id);
        return this.stepsUntilNextQuery = 10;
      } else {
        this.neighbors = (function() {
          var j, len, ref, results;
          ref = this.neighbors;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            n = ref[j];
            if (n.alive) {
              results.push(n);
            }
          }
          return results;
        }).call(this);
        return this.stepsUntilNextQuery--;
      }
    };

    Blob.prototype.getObservables = function() {
      var base, dist, j, k, len, len1, move_so_far, n, name1, ref, ref1, ref2, results;
      ref = this.neighbors;
      for (j = 0, len = ref.length; j < len; j++) {
        n = ref[j];
        if (this.neighborDists[n.id] != null) {
          ref1 = this.neighborDists[n.id], dist = ref1[0], move_so_far = ref1[1];
          move_so_far += this.movedLastTurn + n.movedLastTurn;
          if (move_so_far > self.C.MOVE_UPDATE_AMT) {
            delete this.neighborDists[n.id];
          }
        }
        if ((base = this.neighborDists)[name1 = n.id] == null) {
          base[name1] = [this.simulation.blobDist(this, n), 0];
        }
      }
      ref2 = this.neighbors;
      results = [];
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        n = ref2[k];
        results.push([n, this.neighborDists[n.id][0]]);
      }
      return results;
    };

    Blob.prototype.chooseAction = function() {
      if (this.maintainCurrentAction > 0) {
        if (this.action.type === "hunt" && !this.simulation.isAlive(this.huntTarget.id)) {
          this.maintainCurrentAction = 0;
        } else {
          this.maintainCurrentAction--;
          return;
        }
      }
      this.action = this.geneCode.chooseAction(this.energy, this.getObservables());
      if (this.action.type === "hunt") {
        if (this.huntTarget) {
          this.huntTarget = this.action.argument[0];
          this.maintainCurrentAction = 20;
        }
      }
      if (this.action.type === "repr") {
        this.maintainCurrentAction = Math.round(self.C.REPR_TIME_REQUIREMENT * this.reproSpeedFactor + Math.random());
        return this.reproducing = true;
      }
    };

    Blob.prototype.handleMovement = function() {
      var distance, heading, moveAmt, ref, ref1, targetBlob;
      if (this.action.type === "hunt") {
        if (this.action.argument != null) {
          ref = this.action.argument, targetBlob = ref[0], distance = ref[1];
          heading = this.simulation.getHeading(this.id, targetBlob.id);
          moveAmt = distance - 3;
          this.wandering = null;
        } else {
          if (this.wandering == null) {
            this.wandering = Vector2D.randomHeading();
          }
          heading = this.wandering;
          moveAmt = this.maxMovement;
        }
      } else if (this.action.type === "flee" && (this.action.argument != null)) {
        ref1 = this.action.argument, targetBlob = ref1[0], distance = ref1[1];
        heading = this.simulation.getHeading(this.id, targetBlob.id);
        heading = Vector2D.negateHeading(heading);
        moveAmt = this.maxMovement;
        this.wandering = null;
      } else {
        this.wandering = null;
      }
      if ((heading != null) && (moveAmt != null)) {
        return this.move(heading, moveAmt);
      }
    };

    Blob.prototype.handleAttacks = function() {
      var aBlob, amt, attackDelta, dist, j, len, ref, ref1;
      ref = this.getObservables();
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], aBlob = ref1[0], dist = ref1[1];
        if (dist < this.rad + aBlob.rad + 1) {
          attackDelta = this.attackPower - aBlob.attackPower;
          if (attackDelta >= 0) {
            this.numAttacks++;
            aBlob.numAttacks++;
            amt = Math.min(attackDelta, aBlob.energy);
            this.energy += amt;
            this.attackEnergyThisTurn += amt;
            aBlob.energy -= attackDelta;
            aBlob.attackEnergyThisTurn -= attackDelta + 5;
          }
          this.energy -= self.C.ATTACK_BURN;
        }
      }
      if (isNaN(this.attackEnergyThisTurn)) {
        self.postDebug(this);
        return self.postDebug("NAN attack energy");
      }
    };

    Blob.prototype.wrapUp = function(pos1) {
      this.pos = pos1;
      if (this.action.type === "repr") {
        if (this.maintainCurrentAction === 0) {
          this.reproduce(this.action.argument);
          this.reproducing = null;
        }
      }
      this.calculateEnergyAndRadius();
      if (this.energy < 0 || isNaN(this.energy)) {
        this.simulation.removeBlob(this.id);
        return this.alive = false;
      }
    };

    Blob.prototype.move = function(heading, moveAmt) {
      moveAmt = Math.min(moveAmt, this.maxMovement, this.energy * self.C.MOVEMENT_PER_ENERGY / this.efficiencyFactor);
      moveAmt = Math.max(moveAmt, 0);
      this.energy -= moveAmt * this.efficiencyFactor / self.C.MOVEMENT_PER_ENERGY;
      this.simulation.moveBlob(this.id, heading, moveAmt);
      this.neighborDists = {};
      return this.movedThisTurn = moveAmt;
    };

    Blob.prototype.reproduce = function(childEnergy) {
      var childGenes;
      if (this.energy <= self.C.REPR_ENERGY_COST) {
        if (self.C.HARSH_REPRODUCTION) {
          this.energy -= self.C.REPR_ENERGY_COST / 2;
        }
        return;
      }
      if (childEnergy > (this.energy - self.C.REPR_ENERGY_COST) / 2) {
        if (self.C.HARSH_REPRODUCTION) {
          this.energy -= self.C.REPR_ENERGY_COST / 2;
        }
        return;
      }
      if (this.energy >= childEnergy + self.C.REPR_ENERGY_COST * this.efficiencyFactor) {
        this.energy -= childEnergy + self.C.REPR_ENERGY_COST * this.efficiencyFactor;
        childGenes = GeneCode.copy(this.geneCode);
        return this.simulation.addChildBlob(this.id, childEnergy, childGenes);
      }
    };

    return Blob;

  })();

  Simulation = (function() {
    function Simulation() {
      this.initialized = false;
    }

    Simulation.prototype.initialize = function() {
      this.initialized = true;
      this.blobs = {};
      this.qtree = new QuadTree(self.C.X_BOUND, self.C.Y_BOUND, self.C.QTREE_BUCKET_SIZE);
      this.nBlobs = 0;
      this.nextBlobId = 0;
      this.observedBlobID = null;
      this.blobsRemovedThisStep = [];
      return this.blobsAddedThisStep = {};
    };

    Simulation.prototype.processMessage = function(msg) {
      var i, j, ref, results;
      if (!(this.initialized || msg.type === "updateConstants")) {
        self.postDebug("Recieved msg " + msg + " while uninitialized");
        return;
      }
      switch (msg.type) {
        case "go":
          this.step();
          return this.postBlobData();
        case "killAllBlobs":
          return this.killAllBlobs();
        case "killMostBlobs":
          return this.killMostBlobs();
        case "addRandomBlob":
          return this.addRandomBlob();
        case "addBlobs":
          results = [];
          for (i = j = 0, ref = msg.data; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            results.push(this.addRandomBlob());
          }
          return results;
          break;
        case "updateConstants":
          self.C = msg.data;
          self.postDebug(self.C);
          if (!this.initialized) {
            this.initialize();
          }
          if (self.C.X_BOUND !== this.qtree.xBound || self.C.Y_BOUND !== this.qtree.yBound) {
            return this.resize();
          }
      }
    };

    Simulation.prototype.resize = function() {
      var id, pos, ref, xBound, yBound;
      xBound = self.C.X_BOUND;
      yBound = self.C.Y_BOUND;
      ref = this.qtree.id2point;
      for (id in ref) {
        pos = ref[id];
        if (pos.x > xBound || pos.y > yBound) {
          this.removeBlob(id);
        }
      }
      return this.qtree.resize(self.C.X_BOUND, self.C.Y_BOUND);
    };

    Simulation.prototype.postBlobData = function() {
      var blob, blobStates, id, msg, ref;
      blobStates = {};
      ref = this.blobs;
      for (id in ref) {
        blob = ref[id];
        blobStates[id] = [blob.pos.x, blob.pos.y, blob.rad];
      }
      msg = {
        type: 'blobs',
        blobs: blobStates,
        added: this.blobsAddedThisStep,
        removed: this.blobsRemovedThisStep
      };
      return postMessage(msg);
    };

    Simulation.prototype.observeBlob = function(xCoord, yCoord) {
      var b, clickLocation, nearbyBlobs, prevId, selected;
      self.postDebug("Called observeBlob with " + xCoord + "," + yCoord);
      clickLocation = new Vector2D(xCoord, yCoord);
      if (this.observedBlob != null) {
        prevId = this.observedBlob.id;
        this.observedBlob.observed = null;
        this.observedBlob = null;
      }
      nearbyBlobs = this.getAdjacent(clickLocation, 80);
      nearbyBlobs = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = nearbyBlobs.length; j < len; j++) {
          b = nearbyBlobs[j];
          results.push([b, clickLocation.distSq(this.qtree.id2point[b.id])]);
        }
        return results;
      }).call(this);
      selected = minByIndex(nearbyBlobs, 1);
      if ((selected != null) && selected[1] < selected[0].rad + 10 && selected[0].id !== prevId) {
        selected = selected[0];
        this.observedBlob = selected;
        self.postDebug("Observing blob:" + this.observedBlob.id);
        return this.observedBlob.observed = true;
      }
    };

    Simulation.prototype.step = function() {
      var blob, id, ref, ref1, ref2, ref3, results;
      this.blobsRemovedThisStep = [];
      this.qtree.rebuild();
      ref = this.blobs;
      for (id in ref) {
        blob = ref[id];
        blob.preStep();
        blob.chooseAction();
      }
      ref1 = this.blobs;
      for (id in ref1) {
        blob = ref1[id];
        blob.handleMovement();
      }
      ref2 = this.blobs;
      for (id in ref2) {
        blob = ref2[id];
        blob.handleAttacks();
      }
      ref3 = this.blobs;
      results = [];
      for (id in ref3) {
        blob = ref3[id];
        results.push(blob.wrapUp(this.qtree.id2point[id]));
      }
      return results;
    };

    Simulation.prototype.getNeighbors = function(blobID) {
      var pos, rad;
      pos = this.qtree.id2point[blobID];
      rad = this.blobs[blobID].rad;
      return this.getAdjacent(pos, self.C.NEIGHBOR_DISTANCE + rad * 1.5, blobID);
    };

    Simulation.prototype.getAdjacent = function(position, distance, blobID) {
      var j, len, otherID, queryResult, results;
      queryResult = this.qtree.approximateCircleQuery(position, distance);
      results = [];
      for (j = 0, len = queryResult.length; j < len; j++) {
        otherID = queryResult[j];
        if (otherID !== blobID) {
          results.push(this.blobs[otherID]);
        }
      }
      return results;
    };

    Simulation.prototype.getHeading = function(sourceID, targetID) {
      var sourcePos, targetPos;
      sourcePos = this.qtree.id2point[sourceID];
      targetPos = this.qtree.id2point[targetID];
      return Vector2D.subtract(targetPos, sourcePos).heading();
    };

    Simulation.prototype.moveBlob = function(blobID, heading, moveAmt) {
      var moveVector, newPos, sourcePos;
      sourcePos = this.qtree.id2point[blobID];
      moveVector = Vector2D.headingVector(heading).multiply(moveAmt);
      newPos = moveVector.add(sourcePos);
      newPos.constrainToBound(self.C.X_BOUND, self.C.Y_BOUND);
      return this.qtree.moveObject(blobID, newPos);
    };

    Simulation.prototype.addBlob = function(position, energy, geneCode) {
      var b;
      b = new Blob(this, this.nextBlobId, energy, geneCode, position);
      this.blobs[this.nextBlobId] = b;
      this.blobsAddedThisStep[this.nextBlobId] = [b.red, b.grn, b.blu];
      this.qtree.addObject(this.nextBlobId, position);
      this.nextBlobId++;
      return this.nBlobs++;
    };

    Simulation.prototype.addRandomBlob = function() {
      var pos;
      pos = Vector2D.randomBoundedVector(0, self.C.X_BOUND, 0, self.C.Y_BOUND);
      self.postDebug(self.C.STARTING_ENERGY);
      return this.addBlob(pos, self.C.STARTING_ENERGY);
    };

    Simulation.prototype.addChildBlob = function(parentID, childEnergy, childGenes) {
      var childOffset, childPosition, parentPosition, parentRadius, parentSpeed;
      parentPosition = this.qtree.id2point[parentID];
      parentRadius = this.blobs[parentID].rad;
      parentSpeed = this.blobs[parentID].spd;
      childOffset = Vector2D.randomUnitVector();
      childOffset.multiply(self.C.CHILD_DISTANCE + parentRadius + parentSpeed / 2);
      childPosition = childOffset.add(parentPosition);
      childPosition.constrainToBound(self.C.X_BOUND, self.C.Y_BOUND);
      return this.addBlob(childPosition, childEnergy, childGenes);
    };

    Simulation.prototype.removeBlob = function(blobID) {
      if ((this.observedBlob != null) && this.observedBlob.id === blobID) {
        this.observedBlob = null;
      }
      this.blobs[blobID].alive = false;
      delete this.blobs[blobID];
      this.qtree.removeObject(blobID);
      this.blobsRemovedThisStep.push(blobID);
      return this.nBlobs--;
    };

    Simulation.prototype.killAllBlobs = function() {
      var blob, blobID, ref, results;
      ref = this.blobs;
      results = [];
      for (blobID in ref) {
        blob = ref[blobID];
        results.push(this.removeBlob(blobID));
      }
      return results;
    };

    Simulation.prototype.killMostBlobs = function() {
      var blob, blobID, ref, results;
      ref = this.blobs;
      results = [];
      for (blobID in ref) {
        blob = ref[blobID];
        if (!(Math.random() < .05)) {
          results.push(this.removeBlob(blobID));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Simulation.prototype.isAlive = function(blobID) {
      return blobID in this.blobs;
    };

    Simulation.prototype.blobDistSq = function(blob1, blob2) {
      var p1, p2;
      p1 = this.qtree.id2point[blob1.id];
      p2 = this.qtree.id2point[blob2.id];
      return p1.distSq(p2);
    };

    Simulation.prototype.blobDist = function(blob1, blob2) {
      return Math.sqrt(this.blobDistSq(blob1, blob2));
    };

    return Simulation;

  })();

  self.postDebug = function(msg) {
    return self.postMessage({
      type: 'debug',
      msg: msg
    });
  };

  sim = new Simulation();

  this.onmessage = (function(_this) {
    return function(event) {
      return sim.processMessage(event.data);
    };
  })(this);

}).call(this);
